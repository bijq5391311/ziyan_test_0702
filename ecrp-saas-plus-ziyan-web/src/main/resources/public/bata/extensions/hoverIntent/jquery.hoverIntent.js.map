{"version":3,"sources":["hoverIntent/jquery.hoverIntent.js"],"names":["factory","define","amd","jQuery","fn","hoverIntent","$","cX","cY","_cfg","interval","sensitivity","timeout","INSTANCE_COUNT","track","ev","pageX","pageY","compare","$el","s","cfg","Math","sqrt","pX","pY","off","event","timeoutId","isActive","over","apply","setTimeout","delay","out","data","id","handlerIn","handlerOut","selector","instanceId","extend","isPlainObject","isFunction","handleHover","e","this","hoverIntentData","state","clearTimeout","mousemove","type","on","mouseenter.hoverIntent","mouseleave.hoverIntent"],"mappings":"CAgCA,SAAUA,GACN,YACsB,mBAAXC,SAAyBA,OAAOC,IACvCD,QAAQ,UAAWD,GACZG,SAAWA,OAAOC,GAAGC,aAC5BL,EAAQG,SAEb,SAASG,GACR,YAGA,IAUIC,GAAIC,EAVJC,GACAC,SAAU,IACVC,YAAa,EACbC,QAAS,GAITC,EAAiB,EAMjBC,EAAQ,SAASC,GACjBR,EAAKQ,EAAGC,MACRR,EAAKO,EAAGE,OAIRC,EAAU,SAASH,EAAGI,EAAIC,EAAEC,GAE5B,MAAKC,MAAKC,MAAOH,EAAEI,GAAGjB,IAAKa,EAAEI,GAAGjB,IAAOa,EAAEK,GAAGjB,IAAKY,EAAEK,GAAGjB,IAAQa,EAAIV,aAC9DQ,EAAIO,IAAIN,EAAEO,MAAMb,SACTM,GAAEQ,UAETR,EAAES,UAAW,EAEbd,EAAGC,MAAQT,EAAIQ,EAAGE,MAAQT,QAEnBY,GAAEI,SAAWJ,GAAEK,GACfJ,EAAIS,KAAKC,MAAMZ,EAAI,IAAIJ,MAG9BK,EAAEI,GAAKjB,EAAIa,EAAEK,GAAKjB,EAElBY,EAAEQ,UAAYI,WAAY,WAAWd,EAAQH,EAAII,EAAKC,EAAGC,IAASA,EAAIX,UAFtEU,SAOJa,EAAQ,SAASlB,EAAGI,EAAIC,EAAEc,GAE1B,aADOf,GAAIgB,KAAK,eAAef,EAAEgB,IAC1BF,EAAIH,MAAMZ,EAAI,IAAIJ,IAG7BT,GAAEF,GAAGC,YAAc,SAASgC,EAAUC,EAAWC,GAE7C,GAAIC,GAAa3B,IAGbQ,EAAMf,EAAEmC,UAAWhC,EAClBH,GAAEoC,cAAcL,IACjBhB,EAAMf,EAAEmC,OAAOpB,EAAKgB,GACd/B,EAAEqC,WAAWtB,EAAIa,OACnBb,EAAIa,IAAMb,EAAIS,OAGlBT,EADQf,EAAEqC,WAAWL,GACfhC,EAAEmC,OAAOpB,GAAOS,KAAMO,EAAWH,IAAKI,EAAYC,SAAUA,IAE5DjC,EAAEmC,OAAOpB,GAAOS,KAAMO,EAAWH,IAAKG,EAAWE,SAAUD,GAIrE,IAAIM,GAAc,SAASC,GAEvB,GAAI9B,GAAKT,EAAEmC,UAAUI,GAGjB1B,EAAMb,EAAEwC,MAGRC,EAAkB5B,EAAIgB,KAAK,cAC1BY,IAAmB5B,EAAIgB,KAAK,cAAgBY,KAGjD,IAAIC,GAAQD,EAAgBP,EACvBQ,KAASD,EAAgBP,GAAcQ,GAAUZ,GAAII,IAUtDQ,EAAMpB,YAAaoB,EAAMpB,UAAYqB,aAAaD,EAAMpB,WAG5D,IAAIsB,GAAYF,EAAMrB,MAAQ,oCAAoCa,CAGlE,IAAe,eAAXK,EAAEM,KAAuB,CAEzB,GAAIH,EAAMnB,SAAY,MAEtBmB,GAAMxB,GAAKT,EAAGC,MAAOgC,EAAMvB,GAAKV,EAAGE,MAEnCE,EAAIO,IAAIwB,EAAUpC,GAAOsC,GAAGF,EAAUpC,GAEtCkC,EAAMpB,UAAYI,WAAY,WAAWd,EAAQH,EAAGI,EAAI6B,EAAM3B,IAASA,EAAIX,cACxE,CAEH,IAAKsC,EAAMnB,SAAY,MAEvBV,GAAIO,IAAIwB,EAAUpC,GAElBkC,EAAMpB,UAAYI,WAAY,WAAWC,EAAMlB,EAAGI,EAAI6B,EAAM3B,EAAIa,MAASb,EAAIT,UAKrF,OAAOkC,MAAKM,IAAIC,yBAAyBT,EAAYU,yBAAyBV,GAAcvB,EAAIkB","file":"jquery.hoverIntent.js","sourcesContent":["/*!\n * hoverIntent v1.8.1 // 2014.08.11 // jQuery v1.9.1+\n * http://briancherne.github.io/jquery-hoverIntent/\n *\n * You may use hoverIntent under the terms of the MIT license. Basically that\n * means you are free to use hoverIntent as long as this header is left intact.\n * Copyright 2007, 2014 Brian Cherne\n */\n\n/* hoverIntent is similar to jQuery's built-in \"hover\" method except that\n * instead of firing the handlerIn function immediately, hoverIntent checks\n * to see if the user's mouse has slowed down (beneath the sensitivity\n * threshold) before firing the event. The handlerOut function is only\n * called after a matching handlerIn.\n *\n * // basic usage ... just like .hover()\n * .hoverIntent( handlerIn, handlerOut )\n * .hoverIntent( handlerInOut )\n *\n * // basic usage ... with event delegation!\n * .hoverIntent( handlerIn, handlerOut, selector )\n * .hoverIntent( handlerInOut, selector )\n *\n * // using a basic configuration object\n * .hoverIntent( config )\n *\n * @param  handlerIn   function OR configuration object\n * @param  handlerOut  function OR selector for delegation OR undefined\n * @param  selector    selector OR undefined\n * @author Brian Cherne <brian(at)cherne(dot)net>\n */\n\n(function(factory) {\n    'use strict';\n    if (typeof define === 'function' && define.amd) {\n        define(['jquery'], factory);\n    } else if (jQuery && !jQuery.fn.hoverIntent) {\n        factory(jQuery);\n    }\n})(function($) {\n    'use strict';\n\n    // default configuration values\n    var _cfg = {\n        interval: 100,\n        sensitivity: 6,\n        timeout: 0\n    };\n\n    // counter used to generate an ID for each instance\n    var INSTANCE_COUNT = 0;\n\n    // current X and Y position of mouse, updated during mousemove tracking (shared across instances)\n    var cX, cY;\n\n    // saves the current pointer position coordinates based on the given mousemove event\n    var track = function(ev) {\n        cX = ev.pageX;\n        cY = ev.pageY;\n    };\n\n    // compares current and previous mouse positions\n    var compare = function(ev,$el,s,cfg) {\n        // compare mouse positions to see if pointer has slowed enough to trigger `over` function\n        if ( Math.sqrt( (s.pX-cX)*(s.pX-cX) + (s.pY-cY)*(s.pY-cY) ) < cfg.sensitivity ) {\n            $el.off(s.event,track);\n            delete s.timeoutId;\n            // set hoverIntent state as active for this element (permits `out` handler to trigger)\n            s.isActive = true;\n            // overwrite old mouseenter event coordinates with most recent pointer position\n            ev.pageX = cX; ev.pageY = cY;\n            // clear coordinate data from state object\n            delete s.pX; delete s.pY;\n            return cfg.over.apply($el[0],[ev]);\n        } else {\n            // set previous coordinates for next comparison\n            s.pX = cX; s.pY = cY;\n            // use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)\n            s.timeoutId = setTimeout( function(){compare(ev, $el, s, cfg);} , cfg.interval );\n        }\n    };\n\n    // triggers given `out` function at configured `timeout` after a mouseleave and clears state\n    var delay = function(ev,$el,s,out) {\n        delete $el.data('hoverIntent')[s.id];\n        return out.apply($el[0],[ev]);\n    };\n\n    $.fn.hoverIntent = function(handlerIn,handlerOut,selector) {\n        // instance ID, used as a key to store and retrieve state information on an element\n        var instanceId = INSTANCE_COUNT++;\n\n        // extend the default configuration and parse parameters\n        var cfg = $.extend({}, _cfg);\n        if ( $.isPlainObject(handlerIn) ) {\n            cfg = $.extend(cfg, handlerIn);\n            if ( !$.isFunction(cfg.out) ) {\n                cfg.out = cfg.over;\n            }\n        } else if ( $.isFunction(handlerOut) ) {\n            cfg = $.extend(cfg, { over: handlerIn, out: handlerOut, selector: selector } );\n        } else {\n            cfg = $.extend(cfg, { over: handlerIn, out: handlerIn, selector: handlerOut } );\n        }\n\n        // A private function for handling mouse 'hovering'\n        var handleHover = function(e) {\n            // cloned event to pass to handlers (copy required for event object to be passed in IE)\n            var ev = $.extend({},e);\n\n            // the current target of the mouse event, wrapped in a jQuery object\n            var $el = $(this);\n\n            // read hoverIntent data from element (or initialize if not present)\n            var hoverIntentData = $el.data('hoverIntent');\n            if (!hoverIntentData) { $el.data('hoverIntent', (hoverIntentData = {})); }\n\n            // read per-instance state from element (or initialize if not present)\n            var state = hoverIntentData[instanceId];\n            if (!state) { hoverIntentData[instanceId] = state = { id: instanceId }; }\n\n            // state properties:\n            // id = instance ID, used to clean up data\n            // timeoutId = timeout ID, reused for tracking mouse position and delaying \"out\" handler\n            // isActive = plugin state, true after `over` is called just until `out` is called\n            // pX, pY = previously-measured pointer coordinates, updated at each polling interval\n            // event = string representing the namespaced event used for mouse tracking\n\n            // clear any existing timeout\n            if (state.timeoutId) { state.timeoutId = clearTimeout(state.timeoutId); }\n\n            // namespaced event used to register and unregister mousemove tracking\n            var mousemove = state.event = 'mousemove.hoverIntent.hoverIntent'+instanceId;\n\n            // handle the event, based on its type\n            if (e.type === 'mouseenter') {\n                // do nothing if already active\n                if (state.isActive) { return; }\n                // set \"previous\" X and Y position based on initial entry point\n                state.pX = ev.pageX; state.pY = ev.pageY;\n                // update \"current\" X and Y position based on mousemove\n                $el.off(mousemove,track).on(mousemove,track);\n                // start polling interval (self-calling timeout) to compare mouse coordinates over time\n                state.timeoutId = setTimeout( function(){compare(ev,$el,state,cfg);} , cfg.interval );\n            } else { // \"mouseleave\"\n                // do nothing if not already active\n                if (!state.isActive) { return; }\n                // unbind expensive mousemove event\n                $el.off(mousemove,track);\n                // if hoverIntent state is true, then call the mouseOut function after the specified delay\n                state.timeoutId = setTimeout( function(){delay(ev,$el,state,cfg.out);} , cfg.timeout );\n            }\n        };\n\n        // listen for mouseenter and mouseleave\n        return this.on({'mouseenter.hoverIntent':handleHover,'mouseleave.hoverIntent':handleHover}, cfg.selector);\n    };\n});\n"]}